# Дипломный проект команды мануальных тестировщиков (5-7 21.09.2022)

# Тема дипломной работы: Интернет проекта "Карелия Туристическая".

## Цель дипломной работы:

Разработка и мануальное тестирование проекта "Курелия Туристическая".

## Актуальность работы:

На основании анализа рынка туризма, были сделаны следующие выводы:

* (в процессе разработки)

## В рамках данного проекта требовалось:

* Проанализировать рынок туризма и отдыха в регионе Карелия.

* Определить MVP проекта

* Разработать структуру сайта

* Разработать сайт

* Протестировать сайт

Так как разработка ресурса проводилась по гибким методологиям, тестирование программного продукта производилось на протяжении всей разработки.

## Инструменты, которые использовались для создания проекта:

* Jira, Zephyr Scale, Confluence

* GitHub

* Miro

* Figma

* Adobe PhotoShop

* VSCode

* Google Drive (таблицы и документы)

* Google speed page

* Яндекс.Метрика

## Структура дипломного проекта

## Введение
---

# Теоретическая часть.

**Глава 1.** Основы ручного тестирования веб-приложений 

1.1 Что такое веб-приложение, его особенности

Веб-приложение — клиент-серверное приложение, в котором клиент взаимодействует с веб-сервером при помощи браузера. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными службами.

## Структура веб-приложений 

Веб-приложение, представляет собой пакет, загруженный на клиентской стороне и содержащий множество слоев взаимозависимых модулей, построенных на основе веб-технологий:

* HTML – язык разметки гипертекста, представляющий основанную на тегах систему разметки документов, определяющую структуру и отдельные компоненты того, что в итоге компилируется в объектную модель документа, или DOM.
  
* CSS – каскадная таблица стилей, являющаяся фреймворком для стилизации приложения, с помощью которого идентифицируют и оформляют различные части DOM видимой области страницы. CSS предоставляет возможности вроде выбора элементов по их ID, классу и отношению к другим элементам DOM.

* JavaScript – высокоуровневый интерпретируемый скриптовый язык, с помощью которого прописывается и выполняется все поведение приложения.
  
Функциональность этих основных технологий дополнительно расширяется слоями других технических решений, диапазон которых поистине огромен. Сюда относятся различные JS-фреймворки вроде Angular, React и Vue, CSS-инструменты предварительной/пост-обработки вроде Less и Sass, а также всевозможные механизмы HTML-шаблонизации.

Помимо слоя фронтенда в большинстве приложений также присутствует серверная сторона, или бэкенд, с API, построенным на микросервисах и базах данных. Серверная часть содержит все данные и бизнес-логику, абстрагируя всю эту информацию в соответствующие контракты, к которым фронтенд может обращаться через HTTP-методы, используя нужную форму запроса и учетные данные.

## Какие бывают веб-приложения

Веб-приложения можно разделить на несколько типов, в зависимости от разных сочетаний его основных составляющих: 

* Backend (бэкенд или серверная часть приложения) работает на удаленном компьютере, который может находиться где угодно. Она может быть написана на разных языках программирования: PHP, Python, Ruby, C# и других. Если создавать приложение используя только серверную часть, то в результате любых переходов между разделами, отправок форм, обновления данных, сервером будет генерироваться новый HTML-файл и страница в браузере будет перезагружаться.
  
* Frontend (фронтенд или клиентская часть приложения) выполняется в браузере пользователя. Эта часть написана на языке программирования Javascript. Приложение может состоять только из клиентской части, если не требуется хранить данные пользователя дольше одной сессии. Это могут быть, например, фоторедакторы или простые игрушки.

* Single page application (SPA или одностраничное приложение). Более интересный вариант, когда используются и бэкенд и фронтенд. С помощью их взаимодействия можно создать приложение, которое будет работать совсем без перезагрузок страницы в браузере. Или в упрощенном варианте, когда переходы между разделами вызывают перезагрузки, но любые действия в разделе обходятся без них.

## Как клиент и сервер общаются между собой

Общение клиента с сервером происходит по протоколу HTTP. Основа этого протокола — это запрос от клиента к серверу и ответ сервера клиенту. 

Для запросов обычно используют методы GET, если мы хотим получить данные, и POST, если мы хотим изменить данные. Еще в запросе указывается Host (домен сайта), тело запроса (если это POST-запрос) и много дополнительной технической информации. 

Современные веб-приложения используют протокол HTTPS, расширенную версию HTTP с поддержкой шифрования SSL/TLS. Использование шифрованного канала передачи данных, независимо от важности этих данных, стало хорошим тоном в интернете. 

Есть еще один запрос, который делается перед HTTP. Это DNS (domain name system) запроc. Он нужен для получения ip-адреса, к которому привязан запрашиваемый домен. Эта информация сохраняется в браузере и мы больше не тратим на это время. 

Когда запрос от браузера доходит до сервера, он не сразу попадает в Джанго. Сначала его обрабатывает веб-сервер Nginx. Если запрашивается статический файл (например, картинка), то сам Nginx его отправляет в ответ клиенту. Если запрос не к статике, то Nginx должен проксировать (передать) его в Джанго. 

К сожалению, он этого не умеет. Поэтому используется еще одна программа-прослойка — сервер приложений. Например для приложений на питоне, это могут быть uWSGI или Gunicorn. И вот уже они передают запрос в Джанго. 

После того как Джанго обработал запрос, он возвращает ответ c HTML-страницей или данными, и код ответа. Если все хорошо, то код ответа — 200; если страница не найдена, то — 404; если произошла ошибка и сервер не смог обработать запрос, то — 500. Это самые часто встречающиеся коды. 

1.2 Что такое веб-сайт

Веб-сайт, часто называют сокращённо сайт - это не что иное, как совокупность логически связанных между собой веб-страниц, или просто одна страница. Страницы сайта доступны в Интернете средствами протоколов HTTP или HTTPS. Веб-сайт имеет своё место в интернете, определяемое персональным для каждого сайта адресом, который принято называть URL. Любой веб-сайт имеет своего владельца, владельцем может быть как физическое, так и юридическое лицо.

Веб-сайт состоит из страниц, объединённых общим корневым URL и, как правило, общей логической структурой, темой, оформлением (дизайном) и техническим устройством. В свою очередь Всемирная паутина это не, что иное, как совокупность всех веб-сайтов. Веб-страницы представляют собой текстовые файлы, написанные на языке гипертекстовой разметки HTML или XHTML.

При просмотре веб-страницы, в специальной программе, которую называют браузером, HTML файлы загружаются на компьютер пользователя. После загрузки браузер выводит веб-страницы на экран пользователя. В качестве аппаратного средства для выхода в интернет с целью обзора содержимого веб-страниц могут использоваться различные устройства: персональный компьютер, КПК, некоторые модели игровых приставок и другие устройства, все эти устройства поддерживают стандарты языка HTML / XHTML и веб-страницы на них отображаются одинаково.

Язык HTML / XHTML даёт возможность форматировать страницы, помещать на них текст, гиперссылки, таблицы, картинки и другие объекты. Таблица стилей CSS, которую можно использовать в HTML документах даёт дополнительные возможности для создания внешнего вида веб-страниц.

Страницы на сайте могут быть статичными, то есть они хранятся на веб-сервере виде неизменяемых файлов, а могут быть динамическими, то есть генерироваться прямо на сервере специальной программой, которую ещё называют движок сайта. Движок сайта может предоставлять большой набор возможностей, для изменения содержимого веб-страниц, добавления новые веб-страниц и осуществления других действий по конфигурированию веб-сайта и редактированию информации на нём через веб-интерфейс администрирования, который называют системой управления сайтом или CMS.

1.3 Отличие веб-сайта от веб-приложения

Сайт это в первую очередь что-то информационное и статичное: визитка компании, сайт рецептов, городской портал или вики. Набор подготовленных заранее HTML-файлов, которые лежат на удаленном сервере и отдаются браузеру по запросу. 

Сайты содержат различную статику, которая как и HTML-файл не генерируется на лету. Чаще всего это картинки, CSS-файлы, JS-скрипты, но могут быть и любые другие файлы: mp3, mov, csv, pdf. 

Блоги, визитки с формой для контакта, лендинги с кучей эффектов я тоже отношу для простоты к сайтам. Хотя в отличие от совсем статических сайтов, они уже включают в себя какую-то бизнес-логику. 

А веб-приложение — это что-то технически более сложное. Тут HTML-страницы генерируются на лету в зависимости от запроса пользователя. Почтовые клиенты, соцсети, поисковики, интернет-магазины, онлайн-программы для бизнеса, это все веб-приложения. 

1.4 Что такое тестирование, кто такой тестировщик. Зачем нужно тестирование и когда оно начинается

Тестирование программного обеспечения – это:

– процесс исследования ПО с целью получения информации о качестве продукта;
– процесс проверки соответствия заявленных к продукту требований и реально реализованной функциональности, осуществляемый путем наблюдения за его работой в искусственно созданных ситуациях и на ограниченном наборе тестов, выбранных определенным образом;
– оценка системы с тем, чтобы найти различия между тем, какой система должна быть и какой она есть.

В широком смысле, тестирование – это одна из техник контроля качества (Quality Control), которая включает планирование, составление тестов, непосредственно выполнение тестирования и анализ полученных результатов.

Важно понимать, что тестирование ПО включает не только собственно проведение тестов, но и многие другие действия, связанные с процессом обеспечения качества:

– анализ и планирование;
– разработку тестовых сценариев;
– оценку критериев окончания тестирования;
– написание отчетов;
– рецензирование документации (в том числе и исходного кода);
– проведение статического анализа.

## Почему тестирование необходимо?

Когда мы что-то тестируем, то задаем себе простой вопрос: «работает ли это так, как мы ожидаем?» или, другими словами: соответствует ли реальное поведение объекта тестирования нашим ожиданиям? Если ответ положительный – замечательно, если нет, – мы обмануты в своих ожиданиях, а значит что-то нужно исправлять.
Тестирование необходимо потому, что все мы совершаем ошибки. Некоторые из них могут быть незначительными, в то время как другие – иметь самые разрушительные последствия. Все, что производится человеком, может содержать ошибки (так уж мы, люди, устроены). Именно поэтому любой продукт нуждается в проверке – тестировании, прежде чем его можно будет эффективно и безопасно использовать.
То же самое справедливо и для программного обеспечения (англ. Software).
Программное обеспечение (Software) – компьютерные программы, функции, а также сопровождающая их документация и данные, имеющие отношение к эксплуатации компьютерной системы.
Компьютерные технологии все глубже проникают в нашу повседневную жизнь. Программное обеспечение управляет работой множества окружающих нас вещей – от мобильных телефонов и компьютеров до стиральных машин и кредитных карт. В любом случае, все мы сталкивались с теми или иными ошибками в программах: текстовый редактор, намертво зависший при работе над дипломным проектом, банкомат, «съевший» карточку или просто сайт, который никак не загрузится – все это отнюдь не облегчает нам жизнь.
Однако не все ошибки одинаково опасны – для разных программных систем уровни риска могут отличаться.
Риск (risk):
– фактор, который может привести к негативным последствиям в будущем; как правило, выражается через вероятность наступления таких последствий и их влияние на систему.
– то, что еще не произошло, и может вообще не произойти; потенциальная проблема.
Кроме того, уровень риска будет зависеть от вероятности наступления негативных последствий.
К примеру, одна и та же незначительная ошибка, скажем опечатка, может иметь совершенно разные уровни риска для разных программ:
– опечатка в описании интересов на персональной страничке в социальной сети вряд ли будет иметь существенные последствия, разве что вызовет улыбку у Ваших друзей;
– такая же простая опечатка, допущенная в описании деятельности крупной компании, размещенном на ее сайте, уже опасна, так как косвенно свидетельствует о непрофессионализме ее сотрудников;
– опечатка в коде программы, которая подсчитывает уровни облучения при работе рентгеновского аппарата (например, 100 вместо 10) может иметь самые печальные последствия – вред, нанесенный здоровью и безопасности людей, выльется в потерю доверия к компании и судебные иски со многими нулями.

## Цели тестирования

Можно определить такие основные цели тестирования программного обеспечения:

– Предоставление информации о качестве ПО конечному заказчику;
– Повышение качества ПО;
– Предотвращение появления дефектов.

Цели тестирования могут отличаться, в зависимости от этапа разработки ПО, на котором оно проводится. К примеру, на этапе кодирования целью тестирования будет вызов как можно большего количества сбоев в работе программы, что позволит локализовать и исправить дефекты. В то же время, при приемочном тестировании необходимо  показать, что система работает правильно. В период сопровождения, тестирование в основном необходимо для того, чтобы  убедится в отсутствии новых багов, появившихся во время внесения изменений.

Главная же задача тестирования – поиск дефектов!

## Когда начинается и заканчивается тестирование?
На разных этапах жизненного цикла ПО тестирование проводится в разных формах:

– на этапе определения требований: их анализ и верификация также могут считаться тестированием;
– контроль процесса проектирования на этапе разработки дизайна системы – это тоже форма тестирования;
– как уже упоминалось, разработчики тоже участвуют в тестировании на уровне модульного тестирования.

Труднее определить критерий окончания тестирования, поскольку, согласно принципам тестирования, мы никогда не можем быть уверены в том, что программа на 100% свободна от дефектов. Поэтому используются другие условия:

1. граничные сроки, установленные заранее;
2. выполнение всех предусмотренных тест-кейсов;
3. достижение определенного уровня тестового покрытия;
4. когда после определенного момента, мы практически не находим новых багов или критических дефектов;
5. решение менеджмен

## Кто занимается тестированием и кто такой тестировщик? 

Все зависит от организации процесса и его участников. В IT-индустрии большие компании, как правило, имеют команду специалистов, ответственных за оценку соответствия продукта установленным заказчиком требованиям. То есть, отдел качества. Более того, сами разработчики тоже проводят тестирование, которое называется модульным.

Модульное тестирование (Unit testing) – тестирование отдельных компонентов программной системы. В роли таких компонентов обычно выступают функции или классы.

В большинстве случаев, в процесс тестирования вовлечены такие специалисты:

— Тестировщик ПО (Software tester);
— Разработчик ПО (Software developer);
— Менеджер проекта (Project manager);
— Заказчик (Product owner);
— Конечный пользователь (End user).

В разных компаниях приняты разные обозначения специальности людей, которые занимаются тестированием: тестировщик, специалист по обеспечению качества программного обеспечения (Software Quality Assurance engineer), тест-аналитик (QA analyst) и т.д

## Тестировщик  – это квалифицированный специалист, занимающийся тестированием мобильных приложений, десктопных программ, веб-приложений и другого софта до его официального выхода. В ходе работы тестировщик проверяет наличие ошибок, находит уязвимости, смотрит, адаптировано ли приложение под разные устройства, и выполняет много других операций.## 

## Что делает тестировщик?

Тестировщик ПО старается найти все возможные ошибки, которые могут возникнуть у пользователя при взаимодействии с продуктом. Например, при работе с поисковой строкой проверяются все сценарии: вводится лимитное число символов на разных языках, проверяется ввод «нетипичных» знаков и так далее.

На первый взгляд кажется, что тестировщик работает с продуктом как обычный пользователь, но это не совсем так. Перед началом работы тестировщик составляет план действий, а также определяется с методами, которые будет использовать для тестирования предстоящего продукта. 

Вместе с этим тестировщик взаимодействует с аналитиком, который составляет сценарий, что должно произойти после тестирования определенного этапа. Например, какие данные должны быть на входе, как они обрабатываются и так далее. Тестировщик на основе этого «идет» по продукту и составляет отчет.

Иногда даже детальная проверка не помогает найти все ошибки, поэтому тестировщикам приходится думать над различными ситуациями, способными «поломать программу». В таком процессе задействуются творческие и аналитические способности, которыми хорошо должен обладать тестировщик.

## Кто такие мануальщики и автотестеры

Тестировщиков принято разделять на мануальщиков и автотестеров. Первые находят все ошибки вручную, вторые разрабатывают специальные программы, которые выполняют все действия автоматически.

На практике такого разделения, как правило, нет. Профессиональный тестировщик выполняет работу и за мануальщика, и за автотестера. Если речь идет только о мануальщике, то обычно такие специалисты стараются освоить языки программирования, чтобы не выполнять множество одинаковых действий. Автотестеры напротив стараются избегать ручного тестирования, но в любой момент могут пойти и «потыкать» программу без дополнительного ПО.

Также иногда выделяют дополнительные роли, например security-тестировщика, который занимается проверкой систем безопасности. BI (business intelligence) – тестировщик, работающий с большими объемами данных. В некоторых компаниях есть целые отделы performance-тестирования – контроля производительности ПО и нагрузок на приложения. Usability-тестировщики проверяют, насколько продукт удобен в использовании и привлекателен для пользователя. 

## Чем тестировщик отличается от QA-специалиста

QA (от англ. Quality Assuranse) представляет собой совокупность мероприятий, охватывающих все этапы разработки, выпуска и эксплуатации программного обеспечения. Это активности на всех этапах жизненного цикла ПО, которые предпринимаются для обеспечения требуемого уровня качества выпускаемого продукта.

QA-инженер
- Фокусируется по большей части на процессах и средствах, чем на самом тестировании продукта
- Процессно-ориентированный подход
- Подмножество процессов Software Test Life Cycle – цикла тестирования ПО

Тестировщик
- Фокусируется на тестировании продукта
- Продуктно-ориентированный подход
- Подмножество процессов QC

QC (от англ. Quality Assurance) – процесс проверки качества, который обеспечивает соответствие продукта ранее установленным требованиям. Другими словами, это процесс, который обеспечивает ожидаемое качество продукта.

QC фокусируется на тестировании путем выполнения программ с целью определения дефектов с использованием утвержденных процессов и средств. Вместе с этим он является подмножеством QA.

Тестирование – это часть QC, а QC – часть QA.

QA обеспечивает правильность процесса, а QC предполагает контроль соблюдения требований. Тестировщик же, напротив, обеспечивает сбор данных, которые вносятся в документы, созданные в ходе работы QC.

Выводы:

тестирование позволяет определить работоспособность продукта: правильно ли он был разработан, были ли использованы необходимые инструменты и так далее;
QA обеспечивает соответствие всех этапов разрабатываемого ПО – от планирования и создания до выпуска готового продукта.

1.5 Этапы ручного тестирования веб-приложений

Хороший план тестирования сайта или веб-приложния включает в себя стратегию, задачи тестирования, подход, расписание тестов и среду их выполнения. Стратегия должна быть выстроена так, чтобы сайт в итоге отвечал всем бизнес-требованиям и соответствовал своему назначению.

Что касается подхода к тестированию, то он должен включать в себя:

Модульное тестирование: проверку отдельных частей базы кода с помощью модульных тестов. Подробнее об этом можете почитать в руководстве по JavaScript (https://www.browserstack.com/guide/unit-testing-in-javascript#:~:text=JavaScript%20Unit%20Testing%20is%20a,organized%20in%20the%20test%20suite. англ.) и документации Python (https://docs.python.org/3/library/unittest.html англ.). При этом современные подходы программирования по принципу no-code/low-code и инструменты на основе ИИ позволяют написание модульных тестов частично автоматизировать.
Интеграционное тестирование: подразумевает проверку различных сегментов кода сайта в виде независимых функций или модулей с помощью тестовой программы или прочих инструментов, активируемых при слиянии кода с родительским репозиторием. Все ведущие хостинги вроде GitHub, Gitlab и Bitbucket имеют встроенную поддержку реализации CI/CD.
Системное тестирование: тестирование сайта на уровне пользовательского интерфейса и функционала вроде авторизации, регистрации и прочих потоков. В ходе этого процесса проверяется корректность совместной работы различных элементов сайта. Чаще всего с этой целью используется Selenium, наиболее популярный фреймворк для автоматизации действий браузера.
Приемочное тестирование: как правило, это последняя стадия тестирования, на которой полностью собранное приложение с данными проверяется в продакшн-среде или среде интеграции (стейджинг). Этот этап включает в себя тестирование с привлечением фактических или мнимых пользователей. При этом наиболее эффективным способом управления процессом утверждения изменений в быстро меняющемся UI продукта является автоматизированное визуальное тестирование.
Тестирование производительности: при постепенном увеличении числа пользователей необходимо обеспечить, чтобы сервера справлялись с нагрузкой в пиковые часы использования приложения. Помимо этого, данный этап также подразумевает поддержание сквозной безопасности в каждой точке контакта между сайтом и пользователями с помощью правильного использования HTTP-заголовков и анализа метаданных.

1.5 Источники требований.

Требования к программному обеспечению — совокупность утверждений относительно атрибутов, свойств или качеств программной системы, подлежащей реализации.

Требования это спецификация того, что должно быть реализовано. В них описано поведение системы, свойства системы или ее атрибуты. Они могут служить ограничениями в процессе разработки системы.

Требования создаются в процессе разработки требований к программному обеспечению, в результате анализа требований.

Требования могут выражаться в виде текстовых утверждений и графических моделей.
В классическом техническом подходе совокупность требований используется на стадии проектирования ПО.

Требования также используются в процессе проверки ПО, так как тесты основываются на определённых требованиях.

Этапу разработки требований, возможно, предшествовало технико- экономическое обоснование, или концептуальная фаза анализа проекта.

Фаза разработки требований может быть разбита на выявление требований (сбор, понимание, рассмотрение и выяснение потребностей заинтересованных лиц), анализ (проверка целостности и законченности), спецификация (документирование требований) и проверка правильности.

Требования к продукту и процессу
Требования к продукту. Определение параметров создаваемого программного продукта. Цель – получить хороший конечный продукт: функциональный и удобный в использовании.

Требования к проекту. Определение условий создания и сопровождения программного продукта Разработчиком. Цель — снижение рисков разработки программного продукта и повышение качества.

## Виды требований

По действию:
- Функциональные требования — требования к поведению системы
- Нефункциональные требования — требования к характеру поведения системы

По времени:
- Прошлое время — запросы 
- Настоящее время — текущие функции 
- Будущее время — идеи и планы
  
По приоритету:
- Высокоприоритетные требования (ближайшее будущее) 
- Средреприоритетные требования (отдаленное будущее) 
- Низкоприоритетные требования (гипотетическое будущее)

## Функциональные требования:
- Бизнес-требования— определяют назначение ПО, описываются в документе о видении (vision) и границах проекта (scope).
  
- Пользовательские требования— определяют набор пользовательских задач, которые должна решать программа, а также способы (сценарии) их решения в системе. Пользовательские требования могут выражаться в виде фраз утверждений, в виде способов применения (use case), пользовательских историй (user story), сценариев взаимодействия (scenario).
  
- Функциональные требования— определяют «как» реализовать продукт. Описывается в системной спецификации (system requirement specification, SRS_)_.
  
## Бизнес требования

* описывают, почему организации нужна такая система, то есть цели, которые организация намерена достичь с ее помощью.
* основное их содержание — бизнес-цели организации или клиента, заказывающих систему
  
Примеры:
- Увеличение продаж
- Снижение затрат на ремонт 
- Оптимизация затрат на персонал

## Пользовательские требования

* описывают цели или задачи, которые пользователи должны иметь возможность выполнять с помощью продукта, который в свою очередь должен приносить пользу кому-то.

* Пользовательские требования описывают, что пользователь должен иметь возможность делать с системой.
  
Примеры:
- Формирование заказов на продукцию 
- Определение степени износа узлов 
- Контроль действий пользователя

## Функциональные требования

* определяют, каким должно быть поведение продукта в тех или иных условиях.
  
* Определяют, что разработчики должны создать, чтобы пользователи смогли выполнить свои задачи (пользовательские требования) в рамках бизнес-требований

* Функциональные требования описываются в форме традиционных утверждений со словами «должен» или «должна»

Примеры:
- Система должна добавлять товар в корзину
- Система должна уведомлять оператора о выявленных дефектах
- Система должна проверять местоположение пользователя каждые 5 минут.

## Нефункциональные требования

* Бизнес-правила— определяют ограничения, проистекающие из предметной области и свойств автоматизируемого объекта (предприятия)
* Системные требования и ограничения— определения элементарных операций, которые должна иметь система, а также различных условий, которым она может удовлетворять.
- ограничения на программные интерфейсы 
- требования к атрибутам качества,
- требования к применяемому оборудованию и ПО.

* Атрибуты качества
* Внешние системы и интерфейсы 
* Ограничения

Бизнес-правила
- включают корпоративные политики, правительственные постановления, отраслевые стандарты и вычислительные алгоритмы.
  
- они часто налагают ограничения, определяя, какими функциями должна обладать система, подчиняющаяся соответствующим правилам.
- бизнес-правила становятся источником атрибутов качества

Атрибуты качества представляют собой описание различных измерений характеристик продукта, которые важны для пользователей или для разработчиков и тех, кто будет обслуживать систему, таких как производительность, доступность, применимость, надежность, переносимость и эксплуатационная пригодность.

Внешние интерфейсы - gравила подключений к другим программным системам, аппаратным устройствам и пользователям, а также коммуникационные интерфейсы
Ограничения границы на возможности выбора разработчика при проектировании продукта

## Источники требований

* Федеральное и муниципальное отраслевое законодательство (конституция, законы, распоряжения)
Нормативное обеспечение организации (регламенты, положения, уставы, приказы)

* Текущая организация деятельности объекта автоматизации Модели деятельности (диаграммы бизнес-процессов)
* Представления и ожидания потребителей и пользователей системы
* Журналы использования существующих программно-аппаратных систем
* Конкурирующие программные продукты

## Требования к проекту

* физические ресурсы: компьютеры, устройства, лаборатории, и т. д.

* потребности в обучении персонала

* пользовательская документация, включая обучающие материалы, пособия, справочные руководства и информация о выпусках ПО

* документация для поддержки

* инфраструктурные изменения, которые необходимо внести в рабочую среду

* требования и процедуры для выпуска продукта

* требования и процедуры для перехода со старой на новую систему 

* требования по сертификации продукта

* скорректированные политики, процессы, организационные структуры и аналогичные документы
  
* сорсинг, приобретение и лицензирование ПО сторонних производителей и компонентов оборудования
  
* требования по бета-тестированию, производству, упаковке, маркетингу и дистрибуции
  
* соглашения об уровне обслуживания с клиентами
  
* требования по правовой защите (патенты, товарные знаки или авторское право) интеллектуальной собственности, связанной с разрабатываемым ПО

## Характеристики качественных требований

Характеристики качественных требований по-разному определены различными источниками.

Общепризнанные характеристики:
- Единичность Требование описывает одну и только одну вещь.

- Завершённость Требование полностью определено в одном месте и вся необходимая информация присутствует.

- Последовательность Требование не противоречит другим требованиям и полностью соответствует внешней документации.

- Атомарность Требование «атомарно». То есть оно не может быть разбито на ряд более детальных требований без потери завершённости.

- Отслеживаемость Требование полностью или частично соответствует деловым нуждам как заявлено заинтересованными лицами и документировано.

- Актуальность Требование не стало устаревшим с течением времени. Выполнимость Требование может быть реализовано в пределах проекта.

- Недвусмысленность Требование кратко определено без обращения к техническому жаргону, акронимам и другим скрытым формулировка. Оно выражает объективные факты, не субъективные мнения. Возможна одна и только одна интерпретация. Определение не содержит нечётких фраз. Использование отрицательных утверждений и составных утверждений запрещено.

- Обязательность Требование представляет определённую заинтересованным лицом характеристику, отсутствие которой приведёт к неполноценности решения, которая не может быть проигнорирована. Необязательное требование— противоречие самому понятию требования!

- Проверяемость Реализованость требования может быть определена через один из четырёх возможных методов: осмотр, демонстрация, тест или анализ.

1.6. Виды тестирования.

1. Модульные тесты

Модульные тесты работают на очень низком уровне, близко к исходному коду приложения. Они заключаются в тестировании отдельных методов и функций классов, компонентов или модулей, используемых в ПО. Модульные тесты, как правило, не требуют больших расходов на автоматизацию и могут выполняться сервером непрерывной интеграции очень быстро.

2. Интеграционные тесты

В ходе интеграционного тестирования проверяется, хорошо ли работают вместе различные модули и сервисы, используемые приложением. Например, можно протестировать взаимодействие с базой данных или убедиться, что микросервисы работают вместе так, как задумано. Этот вид тестирования является более затратным, поскольку для проведения тестов требуется запуск различных компонентов приложения.

3. Функциональные тесты

В функциональных тестах основное внимание уделяется бизнес-требованиям к приложению. Они проверяют только результат некоторого действия и не проверяют промежуточные состояния системы при выполнении этого действия.

Иногда возникает путаница между понятиями интеграционных и функциональных тестов, так как и те и другие требуют взаимодействия нескольких компонентов друг с другом. Разница в том, что интеграционный тест нужен просто чтобы убедиться, что вы можете отправлять запросы к базе данных, тогда как функциональный тест будет ожидать получения из базы данных определенного значения в соответствии с требованиями продукта.

4. Сквозные тесты

Сквозное тестирование копирует поведение пользователя при работе с ПО в контексте всего приложения. Оно обеспечивает контроль того, что различные схемы действий пользователя работают должным образом. Сценарии могут быть как очень простыми (загрузка веб-страницы или вход в систему), так и гораздо более сложными (проверка почтовых уведомлений, онлайн-платежей и т. д.).

Сквозные тесты очень полезны, но их выполнение обходится довольно дорого, к тому же, когда они автоматизированы, такие тесты тяжело обслуживать. Рекомендуется иметь в наличии несколько основных сквозных тестов и активнее полагаться на более низкие уровни тестирования (модульные и интеграционные тесты), чтобы получать возможность быстро выявлять критические изменения.

5. Приемочное тестирование

Приемочные тесты — это формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса. При этом во время тестирования должно быть запущено само приложение, и основное внимание уделяется воспроизведению поведения пользователей. В ходе этого тестирования возможен даже замер производительности системы, и в случае несоответствия установленным требованиям внесенные изменения могут быть отклонены.

6. Тестирование производительности

В тестах производительности оценивается работа системы при определенной рабочей нагрузке. С помощью таких тестов можно оценить надежность, скорость, масштабируемость и отзывчивость приложения. Например, это может быть наблюдение за временем отклика при выполнении большого количества запросов или определение поведения системы при работе со значительными объемами данных. Этот вид тестирования позволяет определить, соответствует ли приложение требованиям к производительности, найти узкие места, оценить стабильность при пиковом трафике и многое другое.

7. Smoke-тестирование

Smoke-тесты — это базовые тесты, которые проверяют основные функциональные возможности приложения. Они должны выполняться быстро, поскольку цель таких тестов — убедиться, что основные возможности системы работают как запланировано.

Smoke-тесты полезно запускать сразу после создания новой сборки (для определения, можно ли запускать более ресурсоемкие тесты) или сразу после развертывания (чтобы убедиться, что приложение работает правильно в новой, только что развернутой среде).

  
**Глава 2.** Подготовка к ручному тестированию веб-приложения 

2.1 Разработка тест-плана

План тестирования — это документ, в котором описываются шаги, необходимые для выполнения необходимого тестирования. В нем также указано, кто в организации будет отвечать за каждую задачу, какие функции продукта тестируются и когда проверка должна быть завершена.

Зачем нужен план тестирования? План тестирования поможет выявить потенциальные проблемы на ранней стадии, что сэкономит время и деньги в долгосрочной перспективе.

# Разработка тест-плана

Чтобы создать идеальный процесс тестирования, нужно сосредоточиться на реализации процессов. 

## Структура создания плана тестирования.

1. **Анализ продукта**
   
   При создании плана тестирования необходимо разбить свой продукт на более мелкие компоненты. Это позволит определить лучший процесс тестирования в зависимости от типа создаваемого продукта: 
      * Выявите все функции вашего продукта
      * Определите, сколько тестовых сценариев необходимо для каждой функции
      * Составьте список, что должно быть проверено
   
2. **Анализ целевой аудитории**
   
   Еще один фактор, который следует учитывать при создании плана тестирования — это целевая аудитория. Мы должны убедиться, что ставим клиента на первое место.

3. **Разработка стратегии**
   
   **Собер всех тестовых сценариев и разработка стратегии тестирования** — это поможет определить не только то, что нужно протестировать, но и то, когда это следует протестировать для получения оптимальных результатов.

   **Определите объема тестирования.** Прежде чем приступить к работе, необходимо определить объем тестирования. Это включает в себя решение о том, что необходимо протестировать, кто будет проводить тестирование и когда оно должно быть завершено.

   **Определите типы тестирования.** После того, как мы определили объем, пришло время определить, какие типы тестирования необходимо выполнить. Это включает в себя понимание того, сколько тестов необходимо, а также риски безопасности и конфиденциальности для продукта.

   **Разработка подхода к тестированию.** После того, как мы определили объем, протестировали типы тестирования и определили сопутствующие риски, пришло время создать свой подход к тестированию.

4. **Определите цели**
   
Следующий шаг — выяснить, каковы цели тестирования. Это включает в себя определение ответственных за тестирование, решение о том, что будет тестироваться, когда оно должно быть завершено, и как будут оцениваться результаты. Нам также необходимо определить, какие функции необходимо протестировать и как они будут разбиты (например, основные и второстепенные цели). Нам следует рассмотреть возможность использования целей SMART для теста обеспечения качества.

Технология SMART — современный подход к постановке работающих целей. Система постановки smart — целей позволяет на этапе целеполагания обобщить всю имеющуюся информацию, установить приемлемые сроки работы, определить достаточность ресурсов, предоставить всем участникам процесса ясные, точные, конкретные задачи.

SMART являетсяаббревиатурой, расшифровкакоторой: Specific, Measurable, Achievable, Relevant, Time bound. Каждая буква аббревиатуры SMART означает критерий эффективности поставленных целей.

**Specific = Конкретный.** Цель по SMART должна быть конкретной, что увеличивает вероятность ее достижения. Понятие «Конкретный» означает, что при постановке цели точно определен результат, который мы хотим достичь. Сформулировать конкретную цель поможет ответ на следующие вопросы:

   * Какого результата мы хотим достичь за счет выполнения цели и почему?
   * Кто вовлечен в выполнение цели?
   * Существуют ли ограничения или дополнительные условия, которые необходимы для достижения цели?
  
**Всегда действует правило - одна цель = один результат.** Если при постановке цели выяснилось, что в результате требуется достичь нескольких результатов, то цель должна быть разделена на несколько целей.

**Measurable = Измеримый.** Цель по SMART должна быть измеримой. На этапе постановки цели необходимо установить конкретные критерии для измерения процесса выполнения цели. В постановке измеримой цели помогут ответы на вопросы:

   * Когда будет считаться, что цель достигнута?
   * Какой показатель будет говорить о том, что цель достигнута?
   * Какое значение у данного показателя должно быть для того, чтобы цель считалась достигнутой?

**Achievable or Attainable = Достижимый.** Цели по SMART должны быть достижимы, так как реалистичность выполнения задачи влияет на мотивацию исполнителя. Если цель не является достижимой — вероятность ее выполнения будет стремиться к 0. Достижимость цели определяется на основе собственного опыта с учетом всех имеющихся ресурсов и ограничений.
Ограничениями могут быть: временные ресурсы, инвестиции, трудовые ресурсы, знания и опыт исполнителя, доступ к информации и ресурсам, возможность принимать решения и наличие управленческих рычагов у исполнителя цели.

**Relevant = Значимый.** Для определения значимости цели важно понимать, какой вклад решение конкретной задачи внесет в достижение глобальных стратегических задач компании. В постановке значимой цели поможет следующий вопрос: 

   * Какие выгоды принесет компании решение поставленной задачи? Если при выполнении цели в целом компания не получит выгоды — такая цель считается бесполезной и означает пустую трату ресурсов компании.

P.S Иногда Relevant заменяют на Realictic (реалистичный

**Time bound = Ограниченный во времени.** Цель по SMART должна быть ограничена по выполнению во времени, а значит должен быть определен финальный срок, превышение которого говорит о невыполнении цели. Установление временных рамок и границ для выполнения цели позволяет сделать процесс управления контролируемым. При этом временные рамки должны быть определены с учетом возможности достижения цели в установленные сроки.

5. **Определение критерия теста**
   
Для каждой функции вашего продукта вам необходимо определить, какие критерии должны быть соблюдены, чтобы тест прошел успешно. Эти критерии можно разделить на две основные подкатегории:

   * Критерии приостановки — это условия, которые требуют временной остановки тестирования.
   * Критерии выхода — это условия, составляющие успешное испытание. Когда критерий выхода выполнен, тест может перейти к следующему этапу.

6. **Планировка ресурсов**
   
Теперь, когда есть стратегия и план тестирования, пришло время определить, какие ресурсы необходимо использовать для выполнения работы. Это включает:

   * Люди — сколько человек необходимо для выполнения задач тестирования.
   * Время — сколько времени требуется для тестирования.
   * Инструменты — если в процессе тестирования будут использоваться какие-либо инструменты тестирования и управления задачами.
   * Бюджет — необходимо учитывать размер бюджета на тестирование.

7. **Планировка тестовой среды**
   
Следующим шагом является разработка и планирование среды тестирования. Это включает в себя все, от того, где будут проводиться тесты, до того, как это должно быть сделано и кто будет это делать. Вот основной список дел:

   * Определяем конкретное место, где будет проходить тестирование
   * Определяем типы устройств, необходимых для тестирования
   * Назначаем людей на разные части плана тестирования

8. **График и оценка**

Этот шаг посвящен подготовке плана тестирования к работе. Это включает в себя планирование тестов, когда они должны быть выполнены и сколько времени потребуется для их завершения.

9. **Результат тестирования**
    
И последнее, но не менее важное: необходимо определить результаты. Здесь мы сообщаете о своих выводах после завершения тестирования. Цель состоит в том, чтобы разработать план тестирования, который подходит для нашей среды и целей. Чтобы добиться оптимальных результатов, необходима четкая стратегия.

## Необходимые тестовые компоненты и документы

Прежде чем приступить к реализации плана тестирования, вам необходимо создать определенные компоненты и документы:

   * Идентификатор плана тестирования (ID) — идентификатор плана тестирования требуется, чтобы отличить один план обеспечения качества от другого.
   * Сводка теста (Test summary) — краткий обзор того, что было протестировано, и были ли обнаружены какие-либо проблемы.
   * Тестовые элементы — все характеристики и функции, которые были протестированы.
   * Расписание — включает, когда тесты должны начинаться и останавливаться, кто несет ответственность, где это будет происходить и т.д.
   * Список функций для тестирования — этот пункт представляет собой список функций, которые необходимо протестировать. 
   * Список функций, которые не будут тестироваться — этот пункт представляет собой список функций, которые не будут тестироваться.
   * Подход – как будет проходить тестирование.
   * Критерии прохождения и провала — в этом пункте будут описаны критерии, которые должны быть соблюдены, чтобы тест считался успешным.
   * Требования к приостановке и возобновлению — этот пункт представляет собой список условий, которые требуют приостановки и/или возобновления тестирования.
   * Результаты тестирования — это список всех результатов, которые потребуются после завершения тестирования.
   * Задачи тестирования — список всех задач, которые необходимы для выполнения QA-тестирования.
   * Потребности — список всех элементов, необходимых для успешного завершения тестирования.
   * Смета - плановая смета времени и стоимости.
   * График — список всех этапов и сроков, которые необходимо выполнить.
   * Инструменты и ресурсы — здесь будут подробно описаны любые инструменты, которые будут использоваться для тестирования.
   * Потребности в персонале и обучении — это будет включать в себя, кто нужен, что они будут делать и сколько времени это займет.
   * Риски - включает в себя любые риски со значительными последствиями, которые необходимо учитывать.
   * Предположения и зависимости — включая предположение о том, что требуется для выполнения плана тестирования.
   * Метрики и KPI — включает все элементы, которые необходимо отслеживать.

## Заключение

План тестирования является неотъемлемой частью цикла разработки продукта. Это гарантирует, что продукт готов к выпуску для целевой аудитории. Кроме того, это гарантирует, что все важные функции работают правильно. Автоматизируя бизнес-процессы, мы можем упростить процесс тестирования!

2.2 Составление чек-листов

**Чек-лист (Check List)** – это список, содержащий ряд проверок во время тестирования программного продукта.

# Составление чек-листов

Чек-листы составляют на основе технического задания (ТЗ) — одного или нескольких документов, определяющих цель, структуру, свойства и методы проекта. Тестировщик после знакомства с ТЗ составляет чек-лист, то есть список проверок программного обеспечения. Затем команда или один тестировщик проводят проверки и отмечают исполненные (пройденные) пункты чек-листа подобно тому, как мы вычеркиваем купленные по списку товары.

# Последовательность действий

Сперва тестировщик знакомится с требованиями и только потом составляет по этим требованиям чек-лист. Обычно тестировщики составляют тестовую документацию (то есть чек-листы) на основе технического задания.

Если нужно, требования делят на атомарные части, то есть декомпозируют, разбивают на небольшие составляющие. Это нужно, чтобы с ними было удобнее работать.

Последовательность действий при составлении чек-листа:

   1. Определить все возможные проверки.
   2. Сгруппировать проверки в разделы.
   3. Определить тестовые данные, если они необходимы.
   4. Подумать,какие колонки будут в чек-листе.
   
Затем составляется сам чек-лист.

# Правила составления

1. **Один пункт — одна операция.** Пункты чек-листа — это однозначные атомарные (выполняющее одно действие) и полные (логически завершённые) операции. Например, авторизация в профиль пользователя и редактирование данных пользователя — две разные задачи. В списке проверок их оформляют отдельными пунктами.
2. **Пункты всегда начинаются с существительного или глагола неопределённой формы.** При составлении пунктов важно придерживаться унифицированных форм: начинать их с существительного («Проверка», «Добавление», «Отправка») или неопределённой формы глагола («Проверить», «Добавить», «Отправить»). Так пункты будут понятными и однозначными.
3. **Соблюдение структуры.** Чтобы выполнять чек-лист было удобно, лучше составлять тесты так, чтобы они исходили из логики использования функционала. Например:
   * В рамках раздела «Регистрация и Личный профиль» — регистрация на сайте, редактирование профиля
   * В рамках раздела «Форма обратной связи» — валидация полей, отправка письма, доставка письма.
4. **Ничего не придумано.** Чек-лист важно составлять, опираясь на требования. Не придумывайть то, чего нет в требовании!
5. **Общепринятые названия.** Хорошо, когда в команде все разговаривают на одном языке, используют общую терминологию.

# Виды чек-листов

## Специальные и универсальные

**Специальные** чек-листы создают и используют для конкретных проектов. Их пункты соответствуют его специфике. По специальному чек-листу тестировщик проверяет возможность выполнить уникальное действие, предусмотренное требованиями.

**Универсальные** чек-листы подходят для тестирования проектов одного типа.
Проверка по универсальному чек-листу не привязывается к графическим элементам или конкретной реализации. Проверяется сама возможность выполнить действие.
Для универсального чек-листа составляется абстрактный список проверок.

## Связанные и несвязанные

Пункты чек-листа могут быть в разной степени связаны друг с другом. В зависимости от этого выделяются три типа чек-листов:

   1. Подробный перечень. 
   2. Связанный чек-лист. 
   3. Несвязанный чек-лист.
   
**Подробный перечень (laundry list)** упрощает понимание и восприятие информации. Элементы списка группируются по категориям, порядок не влияет на точность данных. По сути, главная ценность подробного списка — верно подобранные категории, по которым происходит группировка

В **связанном чек-листе (strongly sequential checklist)** последовательность влияет на результат. Ключевой этап работы над созданием связанного чек-листа — корректное размещение информации.

В **несвязанном чек-листе (weakly sequential checklist)** последовательность размещения данных играет скорее психологическую роль, нежели логическую. Несвязанный чек-лист — среднее между подробным перечнем и связанным чек-листом. Связь между элементами есть, но изменение порядка не повлияет на результат проверки.

# Правила выполнения чек-листа

   1. Не пропускать проверки чек-листа. Если какие-то пункты нельзя проверить из-за багов или недоступности среды, надо отметить их и вернуться к ним позже.
   2. Если указываются тестовые данные, нужно использовать именно их.
   3. Указывать результат и комментарий.

# Резолюция

Когда исследуемый объект протестирован, нужно выставить кейсу резолюцию, то есть вердикт — прошёл он проверку или нет. 

Распространённые статусы:

   **passed** — успешно пройден
   **failed** — кейс не прошел проверку
   **skipped** — пропуск проверки
   **blocked** — проверка заблокирована
   **untested** — кейс еще не брали в работу

**passed** ставится, когда исследуемый объект проходит проверку в соответствии с ТЗ. 
**failed** – исследуемый объект не соответствует ТЗ. 
**skipped** — пропуск проверки кейса. 
**blocked** — проверка заблокирована поломанным функционалом, от которого прямо или косвенно зависит тестируемый объект.

# Преимущества и недостатки чек-листов
**Преимущества:**

   1. Чек-листы затрагивают большее количество кейсов, так как при прохождении их можно по-разному выполнять.
   2. Сокращают затраты на содержание и поддержку тестов.
   3. Обеспечивают высокую скорость тестирования: ненужно отмечать результат каждого шага тестировщика, достаточно общего результата проверки.
   4. Позволяют проходить и комбинировать тесты по-разному, в зависимости от предпочтений сотрудников.
   5. Показывают статистику: кто, когда и что проходил — с детализацией по сборке продукта и окружению, на котором проводилось тестирование.
   6. Улучшают представление о системе в целом, показывают статус её готовности.
   7. Показывают объём проделанной и предстоящей работы по тестированию.
   
**Недостатки:**

   1. Начинающие тестировщики не всегда эффективно проводят тесты без достаточно подробной документации.
   2. Чек-листы не возможно использовать для обучения начинающих сотрудников, так как в них недостаточно подробных сведений.
   3. Заказчику или руководству может быть недостаточно того уровня детализации, который предлагают чек-листы.
   4. Неопределённость тестового набора: каждый тестировщик выполняет пункт чек-листа по-своему.

# Программы для составления и хранения чек-листов 

## Google-таблицы

Удобный инструмент: чек-листы наглядные, действия и результаты распределены по ячейкам. 
Всё просто и бесплатно. Но есть минусы:

   * Google-таблицы могут быть запрещены политикой безопасности
   * Документы Excel неудобно модифицировать

## TMS-системы

**Test Management System (TMS)** или системы управления тестированием.

Популярные системы управления тестированием:

   * Test Link
   * Test IT
   * Zephyr
   * qTest
   * PractiTest
   * TestLodge
   * TestRail
   * Qase.io
   * Tematoo
   * Test Collab
   * HPALM
   * Testuff
   * XQual
  
**Плюсы:**

   * Удобное оформление тестовой документации
   * Структурированное отображение
   * Удобное выполнение кейсов
   * Наглядный отчёт после прохождения

**Минусы**

   * Дополнительный инструмент в команде, который может требовать настройки
   * Большинство TMS — платные

**RMS-системы**

**RMS (Requirements Management Systems)** — этосредства поддержки и автоматизации работы с требованиями на протяжении всего жизненного цикла разработки программного продукта. В них тоже можно составлять и хранить чек-листы, но это не очень удобно и затратно по времени.

2.3 Составление тест-кейсов

**Тест-кейс (Test-case)** — это подробное описание проверки. Такое, которое можно будет дать человеку с улицы и он все поймет. В тест-кейсе есть название, предварительные шаги, шаги и результат. И куча других примочек, которые будут зависеть от стандартов оформления на вашей работе. 

Если говорить простыми словами, то тест-кейс – это сценарий, по которому проверяются программные продукты. В отличие от чек-листов, используются в сложных проектах с большой долей ответственности, требуют больше времени для разработки. У тест-кейсов есть обязательные атрибуты и правила создания. Если следовать им, то на выходе вы получите работоспособный сценарий. Вольная трактовка правил приведет к написанию непродуманного тест-кейса и потере времени.

# Атрибуты тест-кейса

Все документы должны оформляться по определенному стандарту. Составление тест-кейсов также имеет строгие критерии. Они включают такие атрибуты, как:

  **Уникальный идентификационный номер,** состоящий из комбинации букв и цифр.
  **Заголовок.** Описывает цель тест-кейса. К примеру, тест-кейс для тестирования страницы входа может иметь заголовок «Проверка входа пользователя с верными данными».
  **Предусловия.** Шаги, предваряющие реализацию тест-кейса. При определенных условиях требуется ввод учетных данных.
  **Шаги.** Изложение действий, составляющих проверку.
  **Постусловия.** Список действий, необходимых для восстановления системы до исходного состояния (указываются, если есть необходимость).
  **Ожидаемый результат.** Предполагаемый результат, к которому мы придем после реализации тест-кейса.
  **Фактический результат.** Состояние системы после совершения всех действий тест-кейса.
  **Статус.** Пройден/успех (Passed/Success)/ провал (Failed)/ блокировка (Blocked). 
  **Требования к среде.** Программное обеспечение, специализированное оборудование и другие предметы, которые потребуются для прохождения тест-кейса, но не указанные в спецификации проекта тестирования.

P.S К некоторым формам тест-кейсов добавляют и другие атрибуты. Среди них:
  
   **Специальные процедурные требования.** Особенные процессы настройки, очистки или реализации для конкретного тест-кейса.
   **Межкейсовые зависимости.** Тест-кейсы, которые необходимо пройти перед выполнением данного.

# Виды тест-кейсов

Тест-кейсы делят на несколько групп в зависимости от входных данных, действий и предполагаемого поведения системы:

   **Позитивные тест-кейсы.** Доказывают, что программное обеспечение отвечает всем требованиям: если были введены верные данные, а пользователь следовал указаниям, система реагирует адекватно.
   **Отрицательные тест-кейсы.** Их результаты позволяют убедиться в способности программного обеспечения правильно реагировать на ошибочные вводные или некорректные действия. Это может быть, например, появление всплывающего окна с подсказкой.
   **Деструктивные тест-кейсы.** Служат для проверки способности системы выдерживать большие нагрузки и внешние воздействия без утери данных пользователя. Должно соблюдаться условие о запрете разрушения аппаратной части.

# Правила разработки тест-кейсов

При разработке тест-кейсов учитывают следующие требования для каждого из его атрибутов.

**Заголовок** - важна четкая короткая формулировка, ясно выражающая суть тест-кейса. Заголовок не должен включать ожидаемый результат и выполняемые шаги.
**Предусловие** - подробно описывает состояние объекта или системы, требуемое для выполнения шагов тест-кейса, список источников информации (описание системы, инструкции), которые тестировщик должен прочитать перед тем, как начать выполнение тест-кейса. Если тестируемая информационная система обладает несколькими средами (прод, тест, препрод…), предусловие не должно включать ссылки на нее. Информацию о ресурсе следует разместить в инструкции, а ссылку добавить в предусловие. В предусловии не прописываются данные для авторизации, их размещают в инструкции, оставляя ссылку в поле тест-кейса для предусловия. Предусловие не должно включать ожидаемый результат и выполняемые шаги. Если есть необходимость держать открытой главную страницу сайта перед тем, как приступаем к шагам проверки, в предусловии отмечается: «открыта главная страница сайта». Придусловие не должно описывать ожидаемый результат.
**Шаги проверки** - ключевые качества: доступность, четкость, последовательность. В шагах проверки важно избавляться от чрезмерной подробности в описании. Например, вместо «первый шаг — нажать на клавиатуре цифру 2, второй шаг — нажать на клавиатуре цифру 5», следует писать «ввести число 25 в данном поле». В шагах проверки применяются только глаголы в неопределенной форме: ввести, нажать, удалить и т.д. Недопустимо: введите, нажмите, удалите. Если требуется добавить комментарии или пояснения, они размещаются в виде инструкции в базе знаний, а в предусловии размещаем ссылку на нее. В шагах проверки не допускаются конкретные статистические данные (названия файлов, логины и пароли) и примеры, во избежание эффекта пестицида.
**Ожидаемый результат** - описывается у каждого шага проверки. Ожидаемый результат содержит внятное и краткое описание состояния, в которое приходит программа или объект после реализации конкретного шага. В ожидаемом результате не допустимы лишние описания.

### Общие требования к тест-кейсам

   * Описание тест-кейсов излагается простой, общедоступной лексикой
   * Хороший тест-кейс не содержит никаких зависимостей с другими. По крайне мере, надо стремиться к их минимизации и избегать ссылок на другие тест-кейсы
   * Тест-кейсы разбивают по назначению на функциональные блоки
   * В тест-кейсы для проверки работы функционала нельзя добавлять скриншоты. В противном случае, при изменении интерфейса проверяемой системы, придется исправлять скриншоты в тысячах тест-кейсов. Размещение скриншотов допустимо только в кейсах, тестирующих отображение страниц и форм.

Соблюдение перечисленных правил поможет составить грамотные тест-кейсы. Это значит, что они будут одинаково удобны в использовании для всех сотрудников проекта, хорошо совместимы и доступны.

# Ошибки при создании тест-кейсов

**Слишком обобщенное название тест-кейса.** Это создает путаницу между различными тест-кейсами одного проекта. Поэтому название должно отражать специфику каждого конкретного тест-кейса.
**Неправильно:** Уведомление пользователя об отсутствии интернет-соединения. 
**Правильно:** Уведомление пользователя о потере Wi-Fi сигнала вручную.

**Употребление повелительного наклонения в тест-кейсе.** Дело не в практической целесообразности, а в элементарной вежливости.

**Неправильно:** перейди на страницу; введи значение и т.д. 
**Правильно:** перейти на страницу; ввести значение и т.д.

**Некликабельные ссылки.** Это касается как гиперссылок внутри программы, так и внешних ресурсов. Каждую ссылку надо делать кликабельной с помощью Ctrl + K.

**Слишком подробные описания действий.** Формулировки шагов тест-кейса не должны вызывать вопросов, но при этом не надо писать очевидные вещи.

**Неправильно:** Наведите мышку и нажмите на зеленую кнопку внизу страницы посередине с надписью «Согласен».
**Правильно:** Нажмите на кнопку «Согласен».

**Слишком краткое описание действий.** Правильный тест-кейс лаконичен, но при этом не требует дополнительных объяснений.

**Неправильно:** Открыть меню «Дополнительные возможности». 
**Правильно:**

   * Нажать на иконку «Профиль».
   * Перейти во вкладку «Настройки».
   * Выбрать пункт «Дополнительные возможности».

# Плюсы и минусы тест-кейсов

Главное достоинство тест-кейса состоит в том, что его может провести практически любой сотрудник компании, не имеющий отношения к работе над проектом. Если к созданию тест-кейса подошли ответственно, исполнитель справится с ним без труда.

Минусы такого типа тестирования тесно взаимосвязаны.

   **Заполнение требует долгой монотонной работы.** Например, при тестировании корректного ввода ФИО надо выполнять простейшие одинаковые шаги: «ввести только символы, «ввести только числа» и т.д. Это особенно заметно, если посмотреть несколько тест-кейсов на один и тот же функционал.
   **Затратное по времени редактирование.** Малейшее изменение содержания сайта требует коррекции сотен сценариев тест-кейса. Не самое увлекательное и довольно выматывающее занятие.
   **Некорректность тест-кейсов.** Возникает из-за того, что при создании нового берутся элементы старого, которые не поменяли.

Именно вероятная неактуальность тест-кейсов делает их неэффективными. Проблема состоит еще и в том, что опытный тестировщик, хорошо знающий проект, без труда заметит несоответствие кейса. Тогда как сотрудник, которому впервые поручили эту задачу и направили несколько кейсов из середины тестового набора, вряд ли заподозрит ошибку.

Работающая схема для решения этой проблемы — применение тест-кейсов с одинаковым алгоритмом выполнения, но с различными вариациями входных параметров и ожидаемыми результатами. Это выглядит как небольшие чек-листы с предусловиями.

P.S **Соответственно, тестирование с помощью тест-кейсов имеет смысл лишь в случае, когда команда регулярно занимается их проверкой и обновлением. А это, очень трудоемкие процессы.**

# Отличия тест-кейсов от чек-листов

Тест-кейсы применяют в крупных серьезных проектах. В частности, когда некорректная реакция системы может стать вопросом жизни и смерти. Например, в проектах, отвечающих за пожарную безопасность, медицинское обслуживание и финансовую сферу, необходимо проводить тестирование с большой ответственностью. Для этого составляются чек-листы (QA) — перечень критериев проверки. Они значительно повышают качество тестирования.

Тест-кейсы для сайтов, мобильных приложений и других несложных систем, как правило, не разрабатываются. Чаще всего в проекте работают не больше двух тестировщиков, которые хорошо знакомы со всеми особенностями продукта. Написание тест-кейсов и их обслуживание не будет оправдано в плане временных и финансовых ресурсов. В данном случае разработчики предпочитают составлять чек-лист, по которому проверяют конкретные функции.

# Заключение

Приоритет тест-кейсов и чек-листов заключается в том, что они делают процесс тестирования программного обеспечения структурированным и доступным для неспециалистов. В чек-листах прописываются объекты проверки, а в тест-кейсах — пошаговый алгоритм.

Применение данного формата тестирования систем позволяет значительно экономить время на проверках. Гораздо рациональнее один раз потратить время на основательную подготовку набора тест-кейсов и чек-листов, чем каждый раз разрабатывать новое тестирование продукта.

2.4 Тест-дизайн и тест-аналитика

# Тест дизайн

Тест-дизайн – это этап тестирования ПО. На нем проектируются и создаются тест-кейсы, которые будут соответсвовать определенным заранее критериями качества и целями тестирования. Цель тест-дизайна — создать наборы тестовых случаев, обеспечивающих оптимальное тестовое покрытие.

Разработка тестов начинается после проведения исследования ПО, когда цели определены, а критерии тестирования заданы и выполняются.

# Техники тест-дизайна

Техники тест-дизайна помогают:

   * Исключить непродуктивные тест-кейсы и сократить общее количество кейсов
   * Покрыть тестами как можно больше функциональности
   * Провести все тесты и не пропустить ничего важного

Для работы с кодом (white-box) важны такие аспекты:

   * Покрытие операторов
   * Покрытие условий
   * Покрытие путей
   * Покрытие функций
   * Покрытие вход/выход
   * Покрытие значений параметров

В работе с требованиями (black-box) тестирование проходит иначе:

   * Классы эквивалентности
   * Граничные значения
   * Попарное тестирование
   * Таблица принятия решений
   * Диаграмма состояний и переходов
   * Тестирование вариантов использования
   * Доменное тестирование.

# Техники тест-дизайна на основании требований

Тест-дизайн – это этап тестирования ПО. На нем проектируются и создаются тест-кейсы, которые будут соответсвовать определенным заранее критериями качества и целями тестирования. Цель тест-дизайна — создать наборы тестовых случаев, обеспечивающих оптимальное тестовое покрытие.

## Классы эквивалентности

Техника **классов эквивалентности** – это разделение диапазона возможных вводимых значений на группы эквивалентных по своему влиянию на систему. Эта техника помогает не только сокращать количество тестов, но и сохранять приемлемое тестовое покрытие.

## Граничные значения

**Граничные значения** – это значения, в которых один класс эквивалентности переходит в другой. По своей сути это техника, которая дополняет технику классов эквивалентности.

Важно проверять граничные значения, потому что именно на границах чаще всего допускаются ошибки при написании кода и формулировании требований.

## Попарное тестирование (pairwise)

**Попарное тестирование** – техника тест-дизайна, при которой тест-кейсы создаются так, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.

Достаточно проверить комбинации пар входных параметров, потому что ошибки чаще всего находятся именно на перекрестке двух параметров. Исключения бывают, но они достаточно редкие.

При попарном тестировании достаточно проверить лишь пары значений. При успешном выполнении тестов на 97% мы можем быть уверены, что проверяемая функциональность работает корректно.

# Таблица принятия решений

**Таблица решений или матрица решений** — способ компактного представления модели со сложной логикой; инструмент для упорядочения сложных бизнес требований, которые должны быть реализованы в продукте. Это взаимосвязь между множеством условий и действий.

Таблица принятия решений содержит следующие элементы:

   **Условия** — список возможных условий
   **Варианты** — комбинация из выполнения и/или невыполнения условий этого списка
   **Действия** — список возможных действий (вариантов исхода)

# Диаграмма состояний и переходов

**Таблица переходов** представляет собой все возможные комбинации начальных и конечных состояний. Она включает в себя действительные и недействительные переходы, инициирующие события, защитные условия и результирующие действия.

Диаграммы состояний и переходов показывают только действительные переходы и исключают недействительные переходы.

# Тестирование вариантов использования

**Тестирование вариантов использования** определяется как метод тестирования программного обеспечения, который помогает идентифицировать тестовые случаи, охватывающие всю систему, от транзакции к транзакции от начала до конечной точки.

Вариант использования или Use-case – это описание конкретного использования системы субъектом или пользователем

Use-cases содержат следующие сведения:

   * Кто использует сайт или приложение
   * Что пользователь хочет сделать
   * Какие шаги делает пользователь, чтобы совершить определенное действие
   * Как сайт или приложение реагируют на действия пользователя

# Доменное тестирование

**Доменное тестирование (domain analysis)** — методика разработки тестов, использующаяся для определения действенных и эффективных тестовых сценариев в случаях, когда множественные параметры могут или должны быть протестированы одновременно.

**Доменное тестирование** применяется для сокращения количества проводимых тестов без потери качества тестирования.

# Тест-анализ

**Тест-анализ** - процесс поиска и рассмотрения информации, необходимой для тестирования. Обычно она есть у людей с хорошими знаниями о системе и способах её использования, в документации (требования, спецификации, описания архитектуры и интеграции и т. п). Такая информация нужна для составления тест-кейсов

**Тест-анализ** — это тот же тест-дизайн, только немного с другим уклоном. На самом деле их часто вообще не различают.

Но если пытаются, то то, что ближе к Коберну:

  * State-Transition Testing 
  * Decision Table Testing 
  * User Case Testing

Это тест-анализ.

А то, что ближе к комбинационному, то есть уже собственно построение тестов — это тест-дизайн:

   * Тест-анализ граничит с аналитикой
   * Тест-дизайн — с автоматизацией

2.5 Баг-репорты и багтрекинговая система

**Баг** — жаргонное слово в программировании, обычно обозначающее ошибку в программе.

**Баг - программная ошибка** — означает ошибку в программе или в системе, из-за которой программа выдает неожиданное поведение и, как следствие, результат. Большинство программных ошибок возникают из-за ошибок, допущенных разработчиками программы в её исходном коде, либо в её дизайне

**Багом (bug)** или дефектом часто называют ошибку в программном коде. Это не совсем ошибка, а скорее несоответствие фактического результата ожидаемому. То, как должна работать программа, описывают в требованиях к разработке. В идеальном мире она будет работать именно так, как её задумали заказчики. Но в реальности можно увидеть не то, что ожидалось. 

В стандарте **ISTQB** для тестировщиков есть несколько похожих на баг терминов, но все они — скорее следствие дефекта. Например, сбой — это ситуация, которую вызвал дефект, а ошибка — действие человека, которое приводит к неправильному результату.

## Виды багов

Когда тестировщик обнаруживает **баг**, то в первую очередь определяет, к какой части программы он относится. Например, при разработке мобильного приложения для интернет-магазина могут быть следующие баги:

   **Визуальный, относится к интерфейсу приложения.** Кнопка «Купить» уехала за пределы экрана.   
   **Функциональный.** Не сохраняются данные: пользователь нажимает кнопку «Купить», но ничего не происходит, или может применить одноразовый купон на скидку два раза.
   **Дефект UX, влияет на удобство.** Чтобы подтвердить мобильный телефон, пользователю приходится несколько раз покидать и возвращаться в мобильное приложение. 
   **Баг нагрузки.** Интернет-магазин должен выдерживать большой наплыв посетителей, например в Чёрную пятницу, поэтому там часто проводят нагрузочное тестирование. Например, искусственно создают ситуацию, когда в один раздел одновременно зашло несколько тысяч пользователей. Если приложение не загружается или зависает — это баг нагрузки.
   **Баг производительности.** Приложение занимает в памяти смартфона слишком много места, работает медленно и быстро тратит заряд батареи. 
   **Баг требований, или логический баг.** До начала разработки приложения или отдельной «фичи» в требованиях что-то не учли. Например, забыли добавить всплывающее оповещение, что при включённом VPN приложение может работать с ошибками. Программист запрограммировал так, как было в требованиях (или как он их понял). В итоге, приложение работает, как описано в требованиях, но не так, как нужно бизнесу.

P.S **Вид бага** — это одна из ключевых его характеристик. Когда понятно, к чему относится дефект, с ним проще разобраться.

# Приоритеты и жизненный цикл бага

У бага есть два важных атрибута — приоритет и серьёзность.

**Серьёзность** показывает, насколько **баг** влияет на возможность работать в программе. Обычно выделяют 5 уровней серьёзности бага. Самый опасный — блокирующий баг. Например, мобильное приложение перестало загружаться, и пользователь видит пустой экран. Самый безвредный — тривиальный баг. Он не влияет на работу приложения, а многие пользователи его даже не заметят. Это может быть, например, опечатка в разделе меню, куда редко заходят.

**Серьёзность бага** - Блокирующая (Blocker).
**Влияние на систему** - Приложение не запускается ни на одном устройстве или выдаёт ошибку при загрузке.

**Серьёзность бага** - Критическая (Critical).
**Влияние на систему** - Часть функционала не работает, но это не блокирует процесс.

**Серьёзность бага** - Значительная (Major).
**Влияние на систему** - Часть логики работает некорректно, но пользователь может решить проблему другим способом.

**Серьёзность бага** - Незначительная (Minor).
**Влияние на систему** - Не нарушает логику приложения.

**Серьёзность бага** -  Тривиальная (Trivial).
**Влияние на систему** - Не относится к логике приложения и не влияет на общее качество продукта.

Приоритет — это критерий, который показывает, насколько быстро нужно исправить дефект. С точки зрения функционала баг может быть несерьёзный и некритичный, но при этом важный для бизнеса. Обычно выделяют три приоритета:

   * Высокий (High) — исправить в первую очередь;
   * Средний (Medium) — исправить, когда разобрались с первой категорией багов;
   * Низкий (Low) — исправить, когда разобрались с багами других приоритетов.

На проектах редко используют оба атрибута — в основном объединяют приоритет и серьёзность, или выбирают что-то одно. Чаще всего это приоритет — с точки зрения планирования важно понимать, что исправлять в первую очередь, а что может подождать.  

**Баг-репорт** — это отчёт об ошибке, который заводится в баг-трекинговой системе. Составлять баг-репорты на каждый дефект может быть трудоёмко даже для большой компании. В этом есть смысл, когда нужно собрать метрики, чтобы комплексно смотреть на процессы и вовремя их настраивать.

Примеры метрик:

   * Насколько меньше багов стала делать команда;
   * В каких модулях системы больше всего багов; 
   * Какой разработчик стал делать неожиданно много багов — можно выяснить, почему

# Как правильно оформить баг‑репорт 

   **Заголовок.** Информативный заголовок помогает понять суть проблемы, не читая весь баг-репорт. При этом он не должен быть слишком коротким или длинным. 
   **Локализация.** Важно убедиться, что это именно дефект, и понять, в чём он заключается. Иначе разработчикам придётся разбираться с проблемой, которая может быть не на их стороне. 
   **Вложения.** Если баг визуальный или UX (поехала вёрстка, не работает кнопка), то без скриншота или скринкаста не разобраться — важно показать, что видит пользователь. 
   **Шаги воспроизведения.** Важно искать золотую середину: описывать те шаги, которые относятся к багу, и так, чтобы другим коллегам было понятно. 
   **Взгляд на проблему.** Тестировщику важно хотя бы пытаться смотреть на проблему с точки зрения бизнеса. Например, текст не помещается в поле, а как этот баг влияет на бизнес? Ответ на вопрос поможет в будущем определять серьёзность и приоритет бага.
   **Фактический и ожидаемый результат.** То, как тестировщик заполнит эти поля, влияет на его коммуникацию по задаче с разработчиком. Если проблема описана непонятно, разработчик не сможет сразу за неё взяться, а будет уточнять детали у тестировщика. 

   # Багтрекинговые системы

   **Bug Tracking Systems** помогают тестировщикам фиксировать и систематизировать ошибки (баги) в программном обеспечении (ПО). **Багтрекинговые системы** — это единая среда, в которой содержится вся информация о тестовом покрытии проекта.

Некоторые популярные BTS:
   
  **ManitsBT.** Простая багтрекинговая система, где все настраивается через один конфигурационный php-файл. К ManitsBG можно подключить внутренний чат и базу данных (только MySQL, MS SQL или PostgreSQL).
  **Redmine.** Бесплатная система с открытым исходным кодом, которую можно установить на собственный сервер. Проекты и задачи доступны всем участникам — их можно не назначать конкретным исполнителям.
  **YouTrack.** Это багтрекинговая система от Jetbrains, которая делает акцент на разработке программного обеспечения. У YouTrack очень простой интерфейс — все задачи по проектам размещаются на Agile-досках (как в Trello). Также YouTrack интегрируется с другими продуктами JetBrains (Space, вся линейка IDE). Для отслеживания задач есть отдельное мобильное приложение для iIOS и Android.
  **Jira Softwatre.** Самый популярный инструмент для управления задачами и багтрекинга

## Глава 3. Практическая часть дипломного проекта

     * Описание проекта, определение ниши в секторе туризма в регионе.

     * Выбор методологии и подходов к разработке ПО.

     * Состав команды и распределение ролей.

  **Часть 1.** Анализ рынка туризма в Карелии.
   
        1.1. Исследование  рынка конкуренции.

        1.2. Сбор и анализ информации об организациях, работающих в сфере туризма. 

        1.3. Выявление целевой аудитории (далее ЦА)

          1.3.1. Проведение социального опроса.

          1.3.2. Анализ полученных данных.

          1.3.3. Определение ЦА.
        
         1.4. Резюме. Актуальность разработки и внедрения проекта.

   **Часть 2.** Разработка интернет ресурса

     1.  Подготовка технического задания проекта.
       
        1.1. Определение MVP проекта.

        1.2. Выбор среды разработки, языка разработки, фреймворков и библиотек для ПО для MVP проекта.
        
         (Язык JS с подключением библиотек bootstrap)
         ()
     2. Разработка в условиях отсутствия UI/UX дизайнера.

     3. Тестирование ПО.

        3.1 Создание тестовой стратегии.

        3.2. Отчет о тестировании.

   ***Выводы***

   ***Список использованой литературы***
      
      1. https://ru.wikipedia.org/wiki/Веб-приложение
      2. https://habr.com/ru/company/ruvds/blog/676752/
      3. https://www.w-polis.ru/blog/articles/chto-takoe-web-sajt/
      4. https://qalight.ua/ru/baza-znaniy/kogda-nachinat-i-zakanchivat-testirovanie/
      5. https://qalight.ua/ru/baza-znaniy/pochemu-testirovanie-neobhodimo/
      6. https://qalight.ua/ru/baza-znaniy/tseli-testirovaniya/
      7. https://qalight.ua/ru/baza-znaniy/chto-takoe-testirovanie-programmnogo-obespecheniya/
      8. https://qalight.ua/ru/baza-znaniy/kto-zanimaetsya-testirovaniem/
      9. https://timeweb.com/ru/community/articles/kto-takoy-testirovshchik-i-chem-on-otlichaetsya-ot-qa
      10. https://www.atlassian.com/ru/continuous-delivery/software-testing/types-of-software-testing
      11. https://gbcdn.mrgcdn.ru/uploads/asset/4266601/attachment/e51787a9b859ace761d08e9ce117630b.pdf
      12. http://cs.petrsu.ru/~kulakov/courses/requirements/lectures/2.property.pdf
      13. https://habr.com/ru/post/676922/
      14. https://kadr.adm-nao.ru/rezerv-upravlencheskih-kadrov-neneckogo-avtonomnogo-okruga/upravlyaj-gramotno/
      15. https://gb.ru/blog/test-kejs/
      16. https://gbcdn.mrgcdn.ru/uploads/asset/4266580/attachment/68984c348f5732f2a8b50379a09fa54f.pdf
      17. https://ru.hexlet.io/courses/qa-engineer-workflow/lessons/test-design-techniques/theory_unit 
      18. http://okiseleva.blogspot.com/2020/11/blog-post_25.html 
      19. https://practicum.yandex.ru/blog/chto-takoe-bug-report-kak-ego-sostavit/
      20. https://robotdreams.cc/blog/257-4-osnovnye-sistemy-bagtrekinga

   ***Приложения***

   ---

   ### Наша комманда

   ***Описание***
   ### В состав входят

   ***Явки, пароли))***

